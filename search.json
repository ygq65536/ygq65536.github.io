[{"title":"简单易用的深度学习算法网络部署方案","url":"/2023/01/29/algorithm-server/","content":"# 1.整体架构  \n整体思路较为简单，主要包括http服务模块和任务管理模块。http服务模块监听指定端口，等待后端的POST请求，收到POST请求后，返回OK给后端并添加计算任务到阻塞队列。任务管理模块并发处理任务队列中的任务，处理完成后回调后端，返回结果。  \n\n本项目基于python3的hhtp.server库实现。  \n\n# 2.代码示例  \n```python  \n\"\"\"\n@author: ygq65536\n简单易用的深度学习算法HTTP服务器程序\n\"\"\"\nimport http.server\nimport json\nimport algorithm_process # 深度学习算法接口\nimport numpy as np\nfrom urllib.request import urlopen\nimport cv2\nimport requests\nfrom multiprocessing import Process\nfrom queue import Queue\nimport logging\n\n\ndef task_process(img_url, task_id, callback_url):\n    \"\"\"下载图片，执行算法，整理结果，回调后端\n    \"\"\"\n    try:\n        resp = urlopen(img_url)\n        image = np.asarray(bytearray(resp.read()), dtype=\"uint8\")\n        image = cv2.imdecode(image, cv2.IMREAD_COLOR)\n        result = algorithm_process(image)\n        result[\"task_id\"] = task_id\n        data_json = json.dumps(result)   #dumps：将python对象解码为json数据\n        headers = {\"Content-Type\":\"application/json\",\n           \"appKey\":\"XXX\",\n           \"appSecret\":\"XXXXXXXXXX\"}\n        callback_resp = requests.post(callback_url, data_json, headers=headers)\n\n    except Exception as ex:\n        return\n\ndef task_manage(q):\n    \"\"\"队列有任务则调用算法模块处理，否则阻塞\n    \"\"\"\n    while True:\n        try:\n            datas = q.get(block=True)\n            task_id = datas[\"task_id\"]\n            img_url = datas[\"img_url\"]\n            callback_url = datas[\"callback_url\"]\n            task_process(img_url, task_id, callback_url)\n        except Exception as ex:\n            continue\n\nclass algorithm_server(http.server.BaseHTTPRequestHandler):\n    \"\"\"http服务类 监听并异步响应post调用\n    \"\"\"\n    def setup(self):\n        self.request.settimeout(10)\n        http.server.BaseHTTPRequestHandler.setup(self)\n\n    def _set_response(self):\n        self.send_response(200)\n        self.send_header('Content-type', 'text/html')\n        self.end_headers()\n\n    def do_GET(self):\n        buf = 'XXXX'\n        self.protocal_version = 'HTTP/1.1'\n        self._set_response()\n        buf = bytes(buf, encoding=\"utf-8\")\n        self.wfile.write(buf)\n\n    def do_POST(self):\n        '''\n        处理通过POST方式传递过来的数据（放入全局任务队列）\n        异步调用模型得到结果并返回\n        '''\n        path = self.path\n        #获取post提交的数据\n        datas = self.rfile.read(int(self.headers['content-length']))\n        datas = datas.decode('utf-8')\n        datas = json.loads(datas)\n        if \"task_id\" in datas:\n            task_id = datas[\"task_id\"]\n        else:\n            buf = '403'\n            buf = bytes(buf, encoding=\"utf-8\")\n            self.wfile.write(buf)\n            return\n        if \"img_url\" in datas:\n            img_url = datas[\"img_url\"]\n        else:\n            buf = '403'\n            buf = bytes(buf, encoding=\"utf-8\")\n            self.wfile.write(buf)\n            return\n        if \"callback_url\" in datas:\n            callback_url = datas[\"callback_url\"]\n        else:\n            buf = '403'\n            buf = bytes(buf, encoding=\"utf-8\")\n            self.wfile.write(buf)\n            return\n        buf = '200'\n        self._set_response()\n        buf = bytes(buf, encoding=\"utf-8\")\n        self.wfile.write(buf)\n        task_queue.put(datas)\n        return\n\ndef start_server(ip, port):\n    http_server = http.server.HTTPServer((ip, int(port)), algorithm_server)\n    try:\n        http_server.serve_forever()  #设置一直监听并接收请求\n    except KeyboardInterrupt:\n        pass\n    http_server.server_close()\n\nif __name__ == '__main__':\n    # 全局任务队列\n    process_num = 8\n    task_queue = Queue(maxsize=0)\n    for _ in range(process_num):\n        Process(target=task_manage, args=(task_queue,)).start()\n    start_server('0.0.0.0', 9753)  # For IPv4 Network Only  \n\n```","tags":["网络后端 python"]}]